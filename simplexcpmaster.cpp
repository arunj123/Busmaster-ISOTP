/* This file is generated by BUSMASTER */
/* VERSION [1.2] */
/* BUSMASTER VERSION [3.2.2] */
/* PROTOCOL [CAN] */

/* Start BUSMASTER include header */
#include <Windows.h>
#include <CANIncludes.h>
/* End BUSMASTER include header */


/* Start BUSMASTER global variable */
#define SEEEDKEY_ENABLED

#define XCPM_REQRES_LEN 8
#define XCPM_TIMEOUT    1000
#define XCPM_BUF_LEN    500

#define NUM_XCPM 1

enum XCPMSTATE {
    XCPM_IDLE,
    XCPM_DISCONNECT,
    XCPM_CONNECT,
    XCPM_SEED,
    XCPM_KEY,
    XCPM_SETUPDAQ,
    
    XCPM_TEMP,
};

enum REQSTATE {
    REQSTATE_INI,
    REQSTATE_WAITRES,
    REQSTATE_COMPLETE,
    REQSTATE_TIMEOUT,
};

struct SEEDKEY {
    uint8_t slen;
    uint8_t klen;
    uint8_t reqcnt;
    uint8_t rescnt;
};

struct REQ {
    uint8_t dlc;

    uint8_t txdata[XCPM_REQRES_LEN];
    uint8_t rxdata[XCPM_REQRES_LEN];

    enum REQSTATE state;
    uint32_t time_cnt;
    bool hasReceived;
}; 

struct XCPM_INFO {
    uint32_t txid;
    uint32_t rxid;
};

struct XCPM {
    struct REQ req;

    struct XCPM_INFO can;

    uint16_t dptr;
    uint16_t tptr;
    uint8_t buf1[XCPM_BUF_LEN];
    uint8_t buf2[XCPM_BUF_LEN];

    struct SEEDKEY s;

    enum XCPMSTATE state;
};


const struct XCPM_INFO xcpmlc[NUM_XCPM] = {
    {1, 2},
};
struct XCPM xcpml[NUM_XCPM];

typedef DWORD __cdecl SEEDKEYPROC(
    BYTE requestedpreviledge,
    BYTE lengthseed,
    BYTE *seed,
    BYTE *lengthkey,
    BYTE *key);

/* End BUSMASTER global variable */


/* Start BUSMASTER Function Prototype  */
GCC_EXTERN void GCC_EXPORT OnTimer_task_1( );
GCC_EXTERN void GCC_EXPORT OnMsg_All(STCAN_MSG RxMsg);
void Utils_sendreceive(struct XCPM *xcpm);
void Utils_xcpm_main(struct XCPM *xcpm);
void Utils_getKey(uint8_t *seed, uint8_t seedlen, uint8_t *key, uint8_t *keylen);
void Utils_SetupDAQ();
/* End BUSMASTER Function Prototype  */

/* Start BUSMASTER Function Wrapper Prototype  */
/* End BUSMASTER Function Wrapper Prototype  */


/* Start BUSMASTER generated function - OnTimer_task_10 */
void OnTimer_task_1( )
{
    uint32_t idx;

    /* Check all ecus */
    for (idx = 0; idx < NUM_XCPM; idx++) {
        xcpml[idx].can = xcpmlc[idx];
        Utils_xcpm_main(&xcpml[idx]);
    }
}/* End BUSMASTER generated function - OnTimer_task_10 */
/* Start BUSMASTER generated function - OnMsg_All */
void OnMsg_All(STCAN_MSG RxMsg)
{
    uint32_t idx;

    /* Check all ecus */
    for (idx = 0; idx < NUM_XCPM; idx++) {
        if(xcpmlc[idx].rxid == RxMsg.id) {
            Trace("Received %x", RxMsg.id);
            xcpml[idx].req.hasReceived = true;
            xcpml[idx].req.dlc = RxMsg.dlc;
            memcpy(xcpml[idx].req.rxdata, RxMsg.data, sizeof(xcpml[idx].req.rxdata));
        }
    }
}/* End BUSMASTER generated function - OnMsg_All */
/* Start BUSMASTER generated function - Utils_sendreceive */
void Utils_sendreceive(struct XCPM *xcpm)
{
    STCAN_MSG sMsg;

    xcpm->req.time_cnt++;

    if( REQSTATE_INI == xcpm->req.state) {
        sMsg.id = xcpm->can.txid;              // Message ID

        // Initialise message structure
        sMsg.dlc = xcpm->req.dlc;                 // Length is 8 Bytes
        memcpy(sMsg.data, xcpm->req.txdata, sizeof(xcpm->req.rxdata) );            

        sMsg.cluster = 1;             // First CAN channel

        // Send the message
        SendMsg(sMsg);

        xcpm->req.state = REQSTATE_WAITRES; //wait for response
    }


    if( REQSTATE_WAITRES == xcpm->req.state) {

        if(xcpm->req.hasReceived) {
            xcpm->req.state = REQSTATE_COMPLETE;
        } else {
            if (XCPM_TIMEOUT <= xcpm->req.time_cnt ) {
                xcpm->req.state = REQSTATE_TIMEOUT;
            }
        }
    }

}/* End BUSMASTER generated function - Utils_sendreceive */
/* Start BUSMASTER generated function - Utils_xcpm_main */
void Utils_xcpm_main(struct XCPM *xcpm)
{
    switch(xcpm->state) {
        case XCPM_IDLE:
            memset(xcpm, 0, sizeof(*xcpm));
            xcpm->state = XCPM_CONNECT;
        break;

        case XCPM_CONNECT:
            if(REQSTATE_INI == xcpm->req.state) {
                xcpm->req.txdata[0] = 0xFF;
                xcpm->req.dlc = 1;
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {

                    #ifdef SEEEDKEY_ENABLED
                    xcpm->state = XCPM_SEED;
                    #else
                    xcpm->state = XCPM_SETUPDAQ;
                    #endif

                    Trace("Connected");
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;

        case XCPM_SEED:
            if(REQSTATE_INI == xcpm->req.state) {
                xcpm->req.txdata[0] = 0xF8;
                xcpm->req.txdata[1] = xcpm->s.reqcnt;
                xcpm->req.txdata[2] = 0x04;
                xcpm->req.dlc = 3;
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {
                    if(xcpm->req.rxdata[0] == 0xFF) {
                        uint8_t readlen = 6;

                        xcpm->s.reqcnt++;

                        /* Update len */
                        if (xcpm->req.rxdata[1] > xcpm->s.slen) {
                            xcpm->s.slen = xcpm->req.rxdata[1];
                        }

                        if (xcpm->req.rxdata[1] < 6) {
                            readlen = xcpm->req.rxdata[1];
                        }

                        memcpy(&xcpm->buf1[xcpm->dptr], &xcpm->req.rxdata[2], readlen);
                        xcpm->dptr += readlen;
                        if(xcpm->dptr >= xcpm->s.slen) {
                            xcpm->s.klen = XCPM_BUF_LEN;
                            Utils_getKey(xcpm->buf1, xcpm->s.slen, xcpm->buf2, &xcpm->s.klen);
                            xcpm->state = XCPM_KEY;
                        }

                    } else {
                        xcpm->state = XCPM_IDLE;
                    }
                    
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;

        case XCPM_KEY:
            if(REQSTATE_INI == xcpm->req.state) {
                uint8_t txlen = 6;

                if((xcpm->s.klen - xcpm->tptr) < 6) {
                    txlen = (xcpm->s.klen - xcpm->tptr);
                }

                xcpm->req.txdata[0] = 0xF7;
                xcpm->req.txdata[1] = (xcpm->s.klen - xcpm->tptr);

                memcpy(&xcpm->req.txdata[2], &xcpm->buf2[xcpm->tptr], txlen);
                xcpm->req.dlc = 2 + txlen;
                xcpm->tptr += txlen;
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {
                    if(xcpm->req.rxdata[0] == 0xFF) {
 
                        if((xcpm->req.rxdata[1] & 0x04) == 0x00) {
                            xcpm->state = XCPM_SETUPDAQ;
                        } else {
                            if(xcpm->tptr >= xcpm->s.klen) {
                                xcpm->state = XCPM_IDLE;
                            }
                        }
                    } else {
                        xcpm->state = XCPM_IDLE;
                    }
                    
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;

        case XCPM_SETUPDAQ:
            
        break;

        case XCPM_TEMP:
        break;

        default:
            xcpm->state = XCPM_IDLE;
        break;
    }
}/* End BUSMASTER generated function - Utils_xcpm_main */
/* Start BUSMASTER generated function - Utils_getKey */
void Utils_getKey(uint8_t *seed, uint8_t seedlen, uint8_t *key, uint8_t *keylen)
{
    HINSTANCE hinstLib; 
    SEEDKEYPROC *ProcAdd;
    BOOL fFreeResult; 
 
    // Get a handle to the DLL module.
 
    hinstLib = LoadLibrary(TEXT("SeedNKeyXcp.dll")); 

    if (hinstLib != NULL) 
    { 
        ProcAdd = (SEEDKEYPROC *) GetProcAddress(hinstLib, "XCP_ComputeKeyFromSeed"); 
 
        // If the function address is valid, call the function.
 
        if (NULL != ProcAdd) 
        {
            Trace("SEED[%d]: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
                     seedlen, seed[0], seed[1], seed[2], seed[3],
                              seed[4], seed[5], seed[6], seed[7], seed[8], seed[9]);
            WORD ret = (ProcAdd) (0x04, seedlen, seed, keylen, key); 
            Trace("XCP_ComputeKeyFromSeed called ret = %u", ret);
            Trace("KEY[%d]: %02X %02X %02X %02X %02X %02X %02X %02X %02X",
                     *keylen, key[0], key[1], key[2], key[3],
                              key[4], key[5], key[6], key[7], key[8]);

        } else {
            Trace("Function not found");
        }
        // Free the DLL module.
 
        fFreeResult = FreeLibrary(hinstLib); 
    }

}/* End BUSMASTER generated function - Utils_getKey */
/* Start BUSMASTER generated function - Utils_SetupDAQ */
void Utils_SetupDAQ(struct XCPM *xcpm)
{
    if(REQSTATE_INI == xcpm->req.state) {
        xcpm->req.txdata[0] = 0xD6; /* Clear daq */
        xcpm->req.dlc = 1;
        Trace("Request daq");
    }

    Utils_sendreceive(xcpm);
    
    if (REQSTATE_WAITRES == xcpm->req.state) {
        /* do nothing */
    } else {
        
        if (REQSTATE_COMPLETE == xcpm->req.state ) {
            xcpm->state = XCPM_TEMP;
        } else {
            xcpm->state = XCPM_IDLE;
        }

        memset(&xcpm->req, 0, sizeof(xcpm->req));
    }
}/* End BUSMASTER generated function - Utils_SetupDAQ */
