/* This file is generated by BUSMASTER */
/* VERSION [1.2] */
/* BUSMASTER VERSION [3.2.2] */
/* PROTOCOL [CAN] */

/* Start BUSMASTER include header */
#include <Windows.h>
#include <CANIncludes.h>
/* End BUSMASTER include header */


/* Start BUSMASTER global variable */
#define SEEEDKEY_ENABLED

#define XCPM_REQRES_LEN 100
#define XCPM_TIMEOUT    1000
#define XCPM_BUF_LEN    500

#define NUM_XCPM 1

enum XCPMSTATE {
    XCPM_IDLE,
    XCPM_DISCONNECT,
    XCPM_CONNECT,
    XCPM_SEED,
    XCPM_KEY,
    XCPM_SETUPDAQ,
    
    XCPM_TEMP,
};

enum REQSTATE {
    REQSTATE_INI,
    REQSTATE_WAITRES,
    REQSTATE_COMPLETE,
    REQSTATE_TIMEOUT,
};

struct SEEDKEY {
    uint8_t slen;
    uint8_t klen;
    uint8_t reqcnt;
    uint8_t rescnt;
};

struct REQ {
    uint8_t dlc;

    uint8_t txdata[XCPM_REQRES_LEN];
    uint8_t rxdata[XCPM_REQRES_LEN];

    enum REQSTATE state;
    uint32_t time_cnt;
    uint8_t expRx;
    uint8_t rxCnt;
    bool hasReceived;
}; 

struct XCPM_INFO {
    uint32_t txid;
    uint32_t rxid;
};

enum DAQSTATE {
    DAQSTATE_INI,
    DAQSTATE_GET_PROCESSOR_INFO,
    DAQSTATE_GET_DAQ_RESOLUTION_INFO,
    DAQSTATE_GET_DAQ_EVENT_INFO,
    DAQSTATE_GET_DAQ_LIST_INFO,
    DAQSTATE_CLEAR_DAQ_LIST,
    DAQSTATE_SENDREMOTECMDS,
    DAQSTATE_DATA_ACQ_IN_PROG,
};

struct DAQEVENT {
    uint8_t DAQ_EVENT_PROPERTIES;
    uint8_t MAX_DAQ_LIST;
    uint8_t name_length;
    uint8_t time_cycle;
    uint8_t time_unit;
    uint8_t priority;
    uint8_t name[20];
};

struct DAQ {
    enum DAQSTATE state;
    bool subcommand; /* to indicate a subcommand */

/* GET_DAQ_PROCESSOR_INFO */
    uint8_t DAQ_PROPERTIES;
    uint16_t MAX_DAQ;
    uint16_t MAX_EVENT_CHANNEL;
    uint8_t MIN_DAQ;
    uint8_t DAQ_KEY_BYTE;

/* GET_DAQ_RESOLUTION_INFO */
    uint8_t Granularity_odt_entry_size_daq;
    uint8_t Max_odt_entry_size_daq;
    uint8_t Timestamp_mode;
    uint8_t Timestamp_ticks;

    uint16_t eIdx;
    struct DAQEVENT events[20];

    uint16_t command_ptr;
};

uint8_t daq_cmdlist[] = {
    4 , 0xD5, 0x00, 0x01, 0x00 ,
    5 , 0xD4, 0x00, 0x00, 0x00, 0x01 ,
    6 , 0xD3, 0x00, 0x00, 0x00, 0x00, 0x01 ,
    6 , 0xE2, 0x00, 0x00, 0x00, 0x00, 0x00 ,
    8 , 0xE1, 0xFF, 0x01, 0x00, 0x54, 0xD0, 0x1B, 0x00 ,
    8 , 0xE0, 0x10, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00 ,
    4 , 0xDE, 0x02, 0x00, 0x00 ,
    4 , 0xDE, 0x02, 0x00, 0x00 ,
    1 , 0xDC ,
    2 , 0xDD, 0x01 ,
};

struct XCPM {
    struct REQ req;

    struct XCPM_INFO can;

    uint16_t dptr;
    uint16_t tptr;
    uint8_t buf1[XCPM_BUF_LEN];
    uint8_t buf2[XCPM_BUF_LEN];

    struct SEEDKEY s;
    struct DAQ d;

    enum XCPMSTATE state;
};


const struct XCPM_INFO xcpmlc[NUM_XCPM] = {
    {1, 2},
};
struct XCPM xcpml[NUM_XCPM];

typedef DWORD __cdecl SEEDKEYPROC(
    BYTE requestedpreviledge,
    BYTE lengthseed,
    BYTE *seed,
    BYTE *lengthkey,
    BYTE *key);

/* End BUSMASTER global variable */


/* Start BUSMASTER Function Prototype  */
GCC_EXTERN void GCC_EXPORT OnTimer_task_1( );
GCC_EXTERN void GCC_EXPORT OnMsg_All(STCAN_MSG RxMsg);
void Utils_sendreceive(struct XCPM *xcpm);
void Utils_xcpm_main(struct XCPM *xcpm);
void Utils_getKey(uint8_t *seed, uint8_t seedlen, uint8_t *key, uint8_t *keylen);
void Utils_SetupDAQ(struct XCPM *xcpm);
uint8_t Utils_CalcExpFrames(uint16_t totallen, uint8_t framelen);
void Utils_PrintInfo(struct XCPM *xcpm);
/* End BUSMASTER Function Prototype  */

/* Start BUSMASTER Function Wrapper Prototype  */
/* End BUSMASTER Function Wrapper Prototype  */


/* Start BUSMASTER generated function - OnTimer_task_10 */
void OnTimer_task_1( )
{
    uint32_t idx;

    /* Check all ecus */    
    for (idx = 0; idx < NUM_XCPM; idx++) {
        xcpml[idx].can = xcpmlc[idx];
        Utils_xcpm_main(&xcpml[idx]);
    }
}/* End BUSMASTER generated function - OnTimer_task_10 */
/* Start BUSMASTER generated function - OnMsg_All */
void OnMsg_All(STCAN_MSG RxMsg)
{
    uint32_t idx;

    /* Check all ecus */
    for (idx = 0; idx < NUM_XCPM; idx++) {
        if(xcpmlc[idx].rxid == RxMsg.id) {

            /* If expected receive is a single frame or, received is negative response */
            if((xcpml[idx].req.expRx <= 1) || (0xFF != RxMsg.data[0]) ) {
                xcpml[idx].req.hasReceived = true;
                xcpml[idx].req.dlc = RxMsg.dlc;
                memcpy(xcpml[idx].req.rxdata, RxMsg.data, RxMsg.dlc);
            } else {
                uint16_t rxptr = 1 + (xcpml[idx].req.rxCnt * 7);
                xcpml[idx].req.rxCnt++;
                if(xcpml[idx].req.rxCnt >= xcpml[idx].req.expRx) {
                    xcpml[idx].req.hasReceived = true;
                }
                xcpml[idx].req.rxdata[0] = 0xFF;
                
                memcpy(&xcpml[idx].req.rxdata[ rxptr ], &RxMsg.data[1], (RxMsg.dlc-1) );
            }
        }
    }
}/* End BUSMASTER generated function - OnMsg_All */
/* Start BUSMASTER generated function - Utils_sendreceive */
void Utils_sendreceive(struct XCPM *xcpm)
{
    STCAN_MSG sMsg;

    xcpm->req.time_cnt++;

    if( REQSTATE_INI == xcpm->req.state) {
        sMsg.id = xcpm->can.txid;              // Message ID

        // Initialise message structure
        sMsg.dlc = xcpm->req.dlc;                 // Length is 8 Bytes
        memcpy(sMsg.data, xcpm->req.txdata, xcpm->req.dlc);            

        sMsg.cluster = 1;             // First CAN channel

        // Send the message
        SendMsg(sMsg);

        xcpm->req.state = REQSTATE_WAITRES; //wait for response
    }


    if( REQSTATE_WAITRES == xcpm->req.state) {

        if(xcpm->req.hasReceived) {
            xcpm->req.state = REQSTATE_COMPLETE;
        } else {
            if (XCPM_TIMEOUT <= xcpm->req.time_cnt ) {
                xcpm->req.state = REQSTATE_TIMEOUT;
            }
        }
    }

}/* End BUSMASTER generated function - Utils_sendreceive */
/* Start BUSMASTER generated function - Utils_xcpm_main */
void Utils_xcpm_main(struct XCPM *xcpm)
{
    switch(xcpm->state) {
        case XCPM_IDLE:
            //Trace("In state XCPM_IDLE");
            memset(xcpm, 0, sizeof(*xcpm));
            xcpm->state = XCPM_CONNECT;
        break;

        case XCPM_CONNECT:
            //Trace("In state XCPM_CONNECT");
            if(REQSTATE_INI == xcpm->req.state) {
                xcpm->req.txdata[0] = 0xFF;
                xcpm->req.dlc = 1;
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {

                    #ifdef SEEEDKEY_ENABLED
                    xcpm->state = XCPM_SEED;
                    #else
                    xcpm->state = XCPM_SETUPDAQ;
                    #endif

                    Trace("Connected");
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;

        case XCPM_SEED:
            //Trace("In state XCPM_SEED");

            if(REQSTATE_INI == xcpm->req.state) {
                xcpm->req.txdata[0] = 0xF8;
                xcpm->req.txdata[1] = xcpm->s.reqcnt;
                xcpm->req.txdata[2] = 0x04;
                xcpm->req.dlc = 3;
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {
                    if(xcpm->req.rxdata[0] == 0xFF) {
                        uint8_t readlen = 6;

                        xcpm->s.reqcnt++;

                        /* Update len */
                        if (xcpm->req.rxdata[1] > xcpm->s.slen) {
                            xcpm->s.slen = xcpm->req.rxdata[1];
                        }

                        if (xcpm->req.rxdata[1] < 6) {
                            readlen = xcpm->req.rxdata[1];
                        }

                        memcpy(&xcpm->buf1[xcpm->dptr], &xcpm->req.rxdata[2], readlen);
                        xcpm->dptr += readlen;
                        if(xcpm->dptr >= xcpm->s.slen) {
                            xcpm->s.klen = (sizeof(xcpm->buf2) > 255)? 255: sizeof(xcpm->buf2);
                            Utils_getKey(xcpm->buf1, xcpm->s.slen, xcpm->buf2, &xcpm->s.klen);
                            xcpm->state = XCPM_KEY;
                        }

                    } else {
                        xcpm->state = XCPM_IDLE;
                    }
                    
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;

        case XCPM_KEY:
            //Trace("In state XCPM_KEY");

            if(REQSTATE_INI == xcpm->req.state) {
                uint8_t txlen = 6;

                if((xcpm->s.klen - xcpm->tptr) < 6) {
                    txlen = (xcpm->s.klen - xcpm->tptr);
                }

                xcpm->req.txdata[0] = 0xF7;
                xcpm->req.txdata[1] = (xcpm->s.klen - xcpm->tptr);

                memcpy(&xcpm->req.txdata[2], &xcpm->buf2[xcpm->tptr], txlen);
                xcpm->req.dlc = 2 + txlen;
                xcpm->tptr += txlen;
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {
                    if(xcpm->req.rxdata[0] == 0xFF) {
 
                        if((xcpm->req.rxdata[1] & 0x04) == 0x00) {
                            xcpm->state = XCPM_SETUPDAQ;
                        } else {
                            if(xcpm->tptr >= xcpm->s.klen) {
                                xcpm->state = XCPM_IDLE;
                            }
                        }
                    } else {
                        xcpm->state = XCPM_IDLE;
                    }
                    
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;

        case XCPM_SETUPDAQ:
            //Trace("In state XCPM_SETUPDAQ");

            Utils_SetupDAQ(xcpm);
        break;

        case XCPM_TEMP:
        break;

        default:
            xcpm->state = XCPM_IDLE;
        break;
    }
}/* End BUSMASTER generated function - Utils_xcpm_main */
/* Start BUSMASTER generated function - Utils_getKey */
void Utils_getKey(uint8_t *seed, uint8_t seedlen, uint8_t *key, uint8_t *keylen)
{
    HINSTANCE hinstLib; 
    SEEDKEYPROC *ProcAdd;
    BOOL fFreeResult; 
 
    // Get a handle to the DLL module.
 
    hinstLib = LoadLibrary(TEXT("SeedNKeyXcp.dll")); 

    if (hinstLib != NULL) 
    { 
        ProcAdd = (SEEDKEYPROC *) GetProcAddress(hinstLib, "XCP_ComputeKeyFromSeed"); 
 
        // If the function address is valid, call the function.
 
        if (NULL != ProcAdd) 
        {
            Trace("SEED[%d]: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
                     seedlen, seed[0], seed[1], seed[2], seed[3],
                              seed[4], seed[5], seed[6], seed[7], seed[8], seed[9]);
            WORD ret = (ProcAdd) (0x04, seedlen, seed, keylen, key); 
            Trace("XCP_ComputeKeyFromSeed called ret = %u", ret);
            Trace("KEY[%d]: %02X %02X %02X %02X %02X %02X %02X %02X %02X",
                     *keylen, key[0], key[1], key[2], key[3],
                              key[4], key[5], key[6], key[7], key[8]);

        } else {
            Trace("Function not found");
        }
        // Free the DLL module.
 
        fFreeResult = FreeLibrary(hinstLib); 
    }

}/* End BUSMASTER generated function - Utils_getKey */
/* Start BUSMASTER generated function - Utils_SetupDAQ */
void Utils_SetupDAQ(struct XCPM *xcpm)
{
    switch(xcpm->d.state) {
        case DAQSTATE_INI:
            memset(&xcpm->d, 0, sizeof(xcpm->d));
            memset(&xcpm->req, 0, sizeof(xcpm->req));

            xcpm->d.state = DAQSTATE_GET_PROCESSOR_INFO;
        break;

        case DAQSTATE_GET_PROCESSOR_INFO:
            if(REQSTATE_INI == xcpm->req.state) {
                xcpm->req.txdata[0] = 0xDA; /* Clear daq */
                xcpm->req.dlc = 1;
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {
                    if(xcpm->req.rxdata[0] == 0xFF) {
                        xcpm->d.DAQ_PROPERTIES    = xcpm->req.rxdata[1];
                        xcpm->d.MAX_DAQ           = xcpm->req.rxdata[2] | (xcpm->req.rxdata[3] << 8);
                        xcpm->d.MAX_EVENT_CHANNEL = xcpm->req.rxdata[4] | (xcpm->req.rxdata[5] << 8);
                        xcpm->d.MIN_DAQ           = xcpm->req.rxdata[6];

                        xcpm->d.state = DAQSTATE_GET_DAQ_RESOLUTION_INFO;
                    } else {
                        xcpm->state = XCPM_IDLE;
                    }
                    
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;


        case DAQSTATE_GET_DAQ_RESOLUTION_INFO:
            if(REQSTATE_INI == xcpm->req.state) {
                xcpm->req.txdata[0] = 0xD9; /* Clear daq */
                xcpm->req.dlc = 1;
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {
                    if(xcpm->req.rxdata[0] == 0xFF) {
                        xcpm->d.Granularity_odt_entry_size_daq = xcpm->req.rxdata[1];
                        xcpm->d.Max_odt_entry_size_daq         = xcpm->req.rxdata[2];
                        xcpm->d.Timestamp_mode                 = xcpm->req.rxdata[5];
                        xcpm->d.Timestamp_ticks                = xcpm->req.rxdata[6];

                        xcpm->d.state = DAQSTATE_GET_DAQ_EVENT_INFO;
                    } else {
                        xcpm->state = XCPM_IDLE;
                    }
                    
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;

        case DAQSTATE_GET_DAQ_EVENT_INFO:
            if(REQSTATE_INI == xcpm->req.state) {
                if (xcpm->d.subcommand) {
                    xcpm->req.txdata[0] = 0xF5; /* Upload name */
                    xcpm->req.txdata[1] = xcpm->d.events[xcpm->d.eIdx - 1].name_length;
                    xcpm->req.expRx = Utils_CalcExpFrames(xcpm->d.events[xcpm->d.eIdx - 1].name_length, 7);
                    xcpm->req.dlc = 2;
                } else {
                    xcpm->req.txdata[0] = 0xD7; /* Clear daq */
                    xcpm->req.txdata[1] = 0x00;
                    xcpm->req.txdata[2] = (uint8_t)xcpm->d.eIdx;
                    xcpm->req.txdata[3] = (uint8_t)(xcpm->d.eIdx >> 8);
                    xcpm->d.eIdx++;
                    xcpm->req.dlc = 4;
                }
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {
                    if(xcpm->req.rxdata[0] == 0xFF) {
                        if(xcpm->d.subcommand) {
                            int i = 1;
                            int j = 0;
                            xcpm->d.subcommand = false;

                            while (j < xcpm->d.events[xcpm->d.eIdx - 1].name_length) {
                                xcpm->d.events[xcpm->d.eIdx - 1].name[j++] = xcpm->req.rxdata[i++];
                            }
                            
                            if(xcpm->d.eIdx > (xcpm->d.MAX_EVENT_CHANNEL-1)) {
                                xcpm->d.state = DAQSTATE_CLEAR_DAQ_LIST;
                            }
                        } else {
                            xcpm->d.subcommand = true;
                            xcpm->dptr = 0;

                            xcpm->d.events[xcpm->d.eIdx - 1].DAQ_EVENT_PROPERTIES = xcpm->req.rxdata[1];
                            xcpm->d.events[xcpm->d.eIdx - 1].MAX_DAQ_LIST = xcpm->req.rxdata[2];
                            xcpm->d.events[xcpm->d.eIdx - 1].name_length = xcpm->req.rxdata[3];
                            xcpm->d.events[xcpm->d.eIdx - 1].time_cycle = xcpm->req.rxdata[4];
                            xcpm->d.events[xcpm->d.eIdx - 1].time_unit = xcpm->req.rxdata[5];
                            xcpm->d.events[xcpm->d.eIdx - 1].priority = xcpm->req.rxdata[6];
                        }
                    }
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;

        case DAQSTATE_CLEAR_DAQ_LIST:
            if(REQSTATE_INI == xcpm->req.state) {
                xcpm->req.txdata[0] = 0xD6; /* Clear daq */
                xcpm->req.dlc = 1;
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {
                    if(xcpm->req.rxdata[0] == 0xFF) {
                        xcpm->d.state = DAQSTATE_SENDREMOTECMDS;
                        Utils_PrintInfo(xcpm);
                    } else {
                        xcpm->state = XCPM_IDLE;
                    }
                    
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;

        case DAQSTATE_SENDREMOTECMDS:
            if(REQSTATE_INI == xcpm->req.state) {
                uint8_t cmdlen = daq_cmdlist[xcpm->d.command_ptr++];
                uint8_t cmdptr = 0;
                while (cmdptr < cmdlen)
                    xcpm->req.txdata[cmdptr++] = daq_cmdlist[xcpm->d.command_ptr++];
                
                xcpm->req.dlc = cmdlen;
            }

            Utils_sendreceive(xcpm);
            
            if (REQSTATE_WAITRES == xcpm->req.state) {
                /* do nothing */
            } else {
                
                if (REQSTATE_COMPLETE == xcpm->req.state ) {
                    if(xcpm->req.rxdata[0] == 0xFF) {

                        /* Exit if complete */
                        if(xcpm->d.command_ptr >= sizeof(daq_cmdlist))
                            xcpm->d.state = DAQSTATE_DATA_ACQ_IN_PROG;
                    } else {
                        xcpm->state = XCPM_IDLE;
                    }
                    
                } else {
                    xcpm->state = XCPM_IDLE;
                }

                memset(&xcpm->req, 0, sizeof(xcpm->req));
            }
        break;

        case DAQSTATE_DATA_ACQ_IN_PROG:
        break;

        default:
        xcpm->state = XCPM_IDLE;
        break;
    }

}/* End BUSMASTER generated function - Utils_SetupDAQ */
/* Start BUSMASTER generated function - Utils_CalcExpFrames */
uint8_t Utils_CalcExpFrames(uint16_t totallen, uint8_t framelen)
{
    uint8_t ret = totallen / framelen;

    if((ret * framelen) < totallen) ret++;

    return ret;
}/* End BUSMASTER generated function - Utils_CalcExpFrames */
/* Start BUSMASTER generated function - Utils_PrintInfo */
void Utils_PrintInfo(struct XCPM *xcpm)
{
    Trace("DAQ_PROPERTIES = 0x%X", xcpm->d.DAQ_PROPERTIES);
    Trace("MAX_DAQ = %u", xcpm->d.MAX_DAQ);
    Trace("MAX_EVENT_CHANNEL = %u", xcpm->d.MAX_EVENT_CHANNEL);
    Trace("MIN_DAQ = %u", xcpm->d.MIN_DAQ);
    Trace("DAQ_KEY_BYTE = %u", xcpm->d.DAQ_KEY_BYTE);
    Trace("Granularity_odt_entry_size_daq = %u", xcpm->d.Granularity_odt_entry_size_daq);
    Trace("Max_odt_entry_size_daq = %u", xcpm->d.Max_odt_entry_size_daq);
    Trace("Timestamp_mode = %u", xcpm->d.Timestamp_mode);
    Trace("Timestamp_ticks = %u", xcpm->d.Timestamp_ticks);

    for (int i = 0; i < xcpm->d.MAX_EVENT_CHANNEL; i++) {
        Trace("Event %d", i);
        Trace("[%d] DAQ_EVENT_PROPERTIES = 0x%X", i, xcpm->d.events[i].DAQ_EVENT_PROPERTIES);
        Trace("[%d] MAX_DAQ_LIST = %u", i, xcpm->d.events[i].MAX_DAQ_LIST);
        Trace("[%d] time_cycle = %u", i, xcpm->d.events[i].time_cycle);
        Trace("[%d] time_unit = %u", i, xcpm->d.events[i].time_unit);
        Trace("[%d] priority = %u", i, xcpm->d.events[i].priority);
        Trace("[%d] name = %s", i, (char *)xcpm->d.events[i].name);
    }
}/* End BUSMASTER generated function - Utils_PrintInfo */
